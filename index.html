<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1.0,user-scalable=no" />
<title>Holiday Clock -- Auto Scale</title>
<style>
  :root{
    --fg: #ffffff;
    --shadow: rgba(0,0,0,0.55);
    --accent: #ffd24d;
    --bg-dark: #0f1720;

    /* these will be overwritten by JS scaling */
    --size-date: 42px;
    --size-time: 150px;
    --size-count: 40px;
    --size-today: 46px;
    --char-size: 150px;
  }

  html,body{
    height:100%;
    margin:0;
    background: var(--bg-dark);
    color:var(--fg);
    font-family: system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
    -webkit-font-smoothing:antialiased;
    -moz-osx-font-smoothing:grayscale;
    overflow:hidden;
  }

  #root{
    position:relative;
    width:100%;
    height:100%;
    display:flex;
    align-items:center;
    justify-content:center;
  }

  #bg {
    position:absolute;
    inset:0;
    z-index:0;
    background-size:cover;
    background-position:center;
  }
  #bg video, #bg img { width:100%; height:100%; object-fit:cover; }

  #overlay-dim {
    position:absolute;
    inset:0;
    background: linear-gradient(180deg, rgba(0,0,0,0.22), rgba(0,0,0,0.34));
    z-index:1;
  }

  /* Layout container uses fraction of the viewport and then JS scales the font sizes */
  .layout {
    z-index:2;
    display:flex;
    width:94%;
    height:92%;
    max-width:1200px;
    justify-content:space-between;
    align-items:center;
  }

  .text-block {
    text-align:left;
    max-width:66%;
    user-select:none;
    /* use relative spacing so everything scales nicely */
  }

  #date {
    font-size: var(--size-date);
    margin:0 0 6px 0;
    line-height:1;
    text-shadow:0 2px 10px var(--shadow);
  }

  #time {
    font-size: var(--size-time);
    margin:0;
    line-height:0.9;
    font-weight:700;
    text-shadow:0 6px 16px var(--shadow);
    white-space:nowrap;
  }

  #countdown {
    font-size: var(--size-count);
    margin-top:8px;
    text-shadow:0 4px 10px var(--shadow);
  }

  #today {
    margin-top:8px;
    font-size: var(--size-today);
    font-weight:700;
    color:var(--accent);
    text-shadow:0 6px 14px var(--shadow);
  }

  #character {
    width: var(--char-size);
    height: var(--char-size);
    display:flex;
    align-items:center;
    justify-content:center;
  }
  #character img, #character video {
    width:100%;
    height:100%;
    object-fit:contain;
    pointer-events:none;
  }

  /* Small fallback safety: keep things inside edges */
  .layout, .text-block { box-sizing: border-box; padding: 6px; }
</style>
</head>
<body>
<div id="root" role="main" aria-live="polite">
  <div id="bg" aria-hidden="true"></div>
  <div id="overlay-dim" aria-hidden="true"></div>

  <div class="layout">
    <div class="text-block">
      <div id="date" aria-hidden="false"></div>
      <div id="time" aria-hidden="false"></div>
      <div id="countdown" aria-hidden="false"></div>
      <div id="today" aria-hidden="false"></div>
    </div>

    <div id="character" aria-hidden="true"></div>
  </div>
</div>

<script>
/* ---------- Configuration ---------- */
// Reference layout: design sizes assume this area (landscape 480x320)
const REF_WIDTH = 480;
const REF_HEIGHT = 320;

// base pixel sizes at reference resolution -- JS will scale from these
const BASE = {
  date: 42,
  time: 150,
  count: 40,
  today: 46,
  char: 150
};

/* ---------- Holiday list (simplified) ---------- */
const holidays = [
  { name:"Thanksgiving",  m:11, d:28 },
  { name:"Christmas",     m:12, d:25 },
  { name:"New Year's",    m:1,  d:1  }
];

/* ---------- DOM refs ---------- */
const elDate = document.getElementById('date');
const elTime = document.getElementById('time');
const elCount = document.getElementById('countdown');
const elToday = document.getElementById('today');
const elChar = document.getElementById('character');
const elBG = document.getElementById('bg');

/* ---------- Utility: compute holiday dates ---------- */
function getNextHoliday(){
  const now = new Date();
  const y = now.getFullYear();
  let upcoming = [];
  holidays.forEach(h=>{
    let dt = new Date(y, h.m-1, h.d);
    if(dt < now) dt = new Date(y+1, h.m-1, h.d);
    upcoming.push({...h, date: dt});
  });
  upcoming.sort((a,b)=>a.date - b.date);
  return upcoming[0];
}

/* ---------- Autoscale logic ---------- */
function applyScale() {
  // Use innerWidth/innerHeight as the actual rendering area Chromium uses on Pi
  const w = window.innerWidth || document.documentElement.clientWidth;
  const h = window.innerHeight || document.documentElement.clientHeight;

  // Compute scale relative to our reference design. Choose min to fit both dimensions.
  let scaleW = w / REF_WIDTH;
  let scaleH = h / REF_HEIGHT;
  let scale = Math.min(scaleW, scaleH);

  // Slight safety clamps so fonts don't go tiny or huge
  scale = Math.max(scale, 0.6);   // don't go below 60% (helps very small displays)
  scale = Math.min(scale, 2.5);   // cap at 250% (prevents absurdly large on desktops)

  // Compute sizes in px
  const datePx  = Math.round(BASE.date * scale);
  const timePx  = Math.round(BASE.time * scale);
  const countPx = Math.round(BASE.count * scale);
  const todayPx = Math.round(BASE.today * scale);
  const charPx  = Math.round(BASE.char * scale);

  // Apply to CSS variables
  document.documentElement.style.setProperty('--size-date', datePx + 'px');
  document.documentElement.style.setProperty('--size-time', timePx + 'px');
  document.documentElement.style.setProperty('--size-count', countPx + 'px');
  document.documentElement.style.setProperty('--size-today', todayPx + 'px');
  document.documentElement.style.setProperty('--char-size', charPx + 'px');

  // Optional: adjust layout spacing for very tall or narrow displays
  // If narrow (portrait), decrease character size moderately
  if (h / w > 1.1) {
    const reducedChar = Math.round(charPx * 0.75);
    document.documentElement.style.setProperty('--char-size', reducedChar + 'px');
  }
}

/* ---------- Time / Countdown update ---------- */
function updateClockAndCountdown() {
  const now = new Date();
  const next = getNextHoliday();

  // Date
  elDate.textContent = now.toLocaleDateString(undefined, {
    weekday: "long", month: "long", day: "numeric"
  });

  // Time: 12-hour numeric without AM/PM
  let rawTime = now.toLocaleTimeString([], { hour: "numeric", minute: "2-digit" });
  elTime.textContent = rawTime.replace(/ ?[AP]M?/i, "");

  // Countdown (days until next holiday)
  const msPerDay = 1000*60*60*24;
  const diff = next.date - now;
  const days = Math.floor(diff / msPerDay);
  if (days === 0) {
    elCount.textContent = "";
    elToday.textContent = "Happy " + next.name + "!";
  } else {
    elToday.textContent = "";
    elCount.textContent = `${days} day${days !== 1 ? "s" : ""} until ${next.name}`;
  }

  // Load / refresh character and background (non-blocking)
  setCharacter(next.name);
  setBG(next.name);
}

/* ---------- Asset loading helpers (non-blocking) ---------- */
function tryAssetFiles(baseName, targets, container, onLoaded) {
  // targets: array of filenames (extensions included) tried in order
  // container: element to receive <img> or <video>
  // onLoaded: callback when asset applied
  let i = 0;
  (function tryNext() {
    if (i >= targets.length) return;
    const url = 'assets/' + targets[i];
    // For efficiency on Pi avoid HEAD -- we'll attempt to load image/video and handle error
    if (targets[i].endsWith('.mp4')) {
      const v = document.createElement('video');
      v.src = url; v.autoplay = true; v.loop = true; v.muted = true; v.playsInline = true;
      v.onloadeddata = () => { container.innerHTML = ''; container.appendChild(v); onLoaded && onLoaded(url); };
      v.onerror = () => { i++; tryNext(); };
    } else {
      const img = new Image();
      img.src = url;
      img.onload = () => { container.innerHTML = ''; container.appendChild(img); onLoaded && onLoaded(url); };
      img.onerror = () => { i++; tryNext(); };
    }
  })();
}

let lastCharacterHoliday = null;
function setCharacter(holidayName) {
  if (!holidayName) return;
  if (holidayName === lastCharacterHoliday) return; // avoid reload thrash
  lastCharacterHoliday = holidayName;
  elChar.innerHTML = '';
  const base = holidayName.toLowerCase().replace(/[^a-z0-9]/g, '');
  const files = [`${base}-char.webp`, `${base}-char.gif`, `${base}-char.mp4`];
  tryAssetFiles(base, files, elChar, ()=>{/*noop*/});
}

let lastBgHoliday = null;
function setBG(holidayName) {
  if (!holidayName) return;
  if (holidayName === lastBgHoliday) return;
  lastBgHoliday = holidayName;
  elBG.innerHTML = '';
  const base = holidayName.toLowerCase().replace(/[^a-z0-9]/g, '');
  const files = [`${base}-bg.webp`, `${base}-bg.jpg`, `${base}-bg.mp4`];
  tryAssetFiles(base, files, elBG, ()=>{/*noop*/});
}

/* ---------- Init ---------- */
function init() {
  applyScale();
  updateClockAndCountdown();

  // update every second
  setInterval(updateClockAndCountdown, 1000);

  // Recompute scale on resize/orientation
  let resizeTimeout;
  function onResize() {
    // Debounce slightly to avoid thrash while rotating
    clearTimeout(resizeTimeout);
    resizeTimeout = setTimeout(() => {
      applyScale();
    }, 80);
  }
  window.addEventListener('resize', onResize);
  window.addEventListener('orientationchange', onResize);

  // Also apply a small hack for devices that don't report correct innerWidth initially:
  // run again after a short delay
  setTimeout(()=>{ applyScale(); }, 300);
}

// Start
init();
</script>
</body>
</html>