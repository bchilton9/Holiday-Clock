<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1.0,user-scalable=no" />
<title>Holiday Clock — Themes + Runners</title>
<style>
  :root{
    --bg: #000;
    --fg: #fff;
    --shadow: rgba(0,0,0,0.55);

    /* autoscale vars (overwritten by JS) */
    --size-date: 42px;
    --size-time: 200px;
    --size-count: 40px;
    --size-today: 46px;
  }

  html,body{
    height:100%;
    margin:0;
    background:var(--bg);
    color:var(--fg);
    font-family: system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
    -webkit-font-smoothing:antialiased;
    -moz-osx-font-smoothing:grayscale;
    transition: background 1.2s ease, color 1.2s ease;
    overflow:hidden;
  }

  #root{
    position:relative;
    width:100%;
    height:100%;
    display:flex;
    align-items:center;
    justify-content:center;
  }

  .layout {
    z-index:2;
    display:flex;
    width:94%;
    height:92%;
    max-width:1200px;
    justify-content:center;
    align-items:center;
  }

  .text-block {
    width:100%;
    text-align:center;
    user-select:none;
    display:flex;
    flex-direction:column;
    align-items:center;
    justify-content:center;
    pointer-events:none;
  }

  #date, #countdown, #today {
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
  }

  #date { font-size: var(--size-date); margin:0 0 8px 0; text-shadow:0 2px 10px var(--shadow); }
  #time { font-size: var(--size-time); margin:0; line-height:0.9; font-weight:700; text-shadow:0 6px 16px var(--shadow); white-space:nowrap; }
  #countdown { font-size: var(--size-count); margin-top:10px; text-shadow:0 4px 10px var(--shadow); }
  #today { margin-top:10px; font-size: var(--size-today); font-weight:700; text-shadow:0 6px 14px var(--shadow); }

  /* Runner (character) container: positioned on top of everything */
  .runner {
    position: absolute;
    bottom: 6%;               /* small offset from bottom so it stays off text */
    left: -25%;               /* start off-screen */
    width: 18vmin;            /* responsive size; JS can override via inline style */
    height: auto;
    z-index: 9999;
    pointer-events: none;
    user-select: none;
    will-change: transform, left;
    filter: drop-shadow(0 6px 8px rgba(0,0,0,0.45));
  }

  /* If sprite sheet used (png), animate background-position with steps */
  .sprite-run {
    background-repeat: no-repeat;
    background-size: cover;
    width: 100%;
    height: 100%;
    display:block;
  }

  /* movement animation across screen (we set duration inline) */
  @keyframes runAcross {
    0% { transform: translateX(-120%); }
    100% { transform: translateX(220%); }
  }

  /* subtle festive text animations (pulse) */
  .festive {
    animation: pulseColor 2.6s ease-in-out infinite;
  }
  @keyframes pulseColor {
    0% { text-shadow:0 6px 8px rgba(255,255,255,0.06); transform: translateY(0); }
    50% { text-shadow:0 12px 22px rgba(255,255,255,0.12); transform: translateY(-2px); }
    100% { text-shadow:0 6px 8px rgba(255,255,255,0.06); transform: translateY(0); }
  }

  /* Safety for very narrow portrait screens */
  @media (max-width:360px) {
    #time { letter-spacing: -0.02em; }
  }
</style>
</head>
<body>
  <div id="root" role="main" aria-live="polite">
    <div class="layout">
      <div class="text-block">
        <div id="date"></div>
        <div id="time"></div>
        <div id="countdown"></div>
        <div id="today"></div>
      </div>
    </div>
  </div>

<script>
/* ============================
   CONFIG
   ============================ */

const REF_W = 480, REF_H = 320; // reference for scaling
const BASE = { date: 40, time:200, count:38, today:44 };

/* two-week pre-window in ms */
const PRE_WINDOW_MS = 14 * 24 * 60 * 60 * 1000;

/* holidays and their dates / keys (month is 1-based) */
const HOLIDAYS = [
  { key: "newyears",    name: "New Year's",        m:1,  d:1 },
  { key: "valentine",   name: "Valentine's Day",   m:2,  d:14 },
  { key: "stpatricks",  name: "St. Patrick's Day", m:3,  d:17 },
  { key: "easter",      name: "Easter",            m:null, d: "easter" }, // computed
  { key: "memorial",    name: "Memorial Day",      m:5,  d:"lastMonday" },
  { key: "independence",name: "4th of July",       m:7,  d:4 },
  { key: "labor",       name: "Labor Day",         m:9,  d:"firstMonday" },
  { key: "halloween",   name: "Halloween",         m:10, d:31 },
  { key: "thanksgiving",name: "Thanksgiving",      m:11, d:"fourthThursday" },
  { key: "christmas",   name: "Christmas",         m:12, d:25 }
];

/* theme palettes (TFT-safe mid-tones) */
const THEME = {
  "newyears": {
    backgrounds: ["#1A0033","#330066","#00111a"],
    texts:       ["#FFD700","#E8D6FF","#FFFFFF"]
  },
  "valentine": {
    backgrounds: ["#E63963","#FF8AAE","#FFC2D4"],
    texts:       ["#FFFFFF","#FFE6EE","#FFF5FA"]
  },
  "stpatricks": {
    backgrounds: ["#0B6E27","#1FA040","#3BD25B"],
    texts:       ["#FFFFFF","#E3FFD8","#F1FFEB"]
  },
  "easter": {
    backgrounds: ["#FFD6E8","#D9D4FF","#D1F7FF"],
    texts:       ["#6A3F99","#8F538D","#725679"]
  },
  "memorial": {
    backgrounds: ["#1F3A93","#3A62C9","#6A89CC"],
    texts:       ["#FFFFFF","#DCEBFF","#EAF4FF"]
  },
  "independence": {
    backgrounds: ["#0A1A59","#8B0000","#001133"],
    texts:       ["#FFFFFF","#FFCCCC","#DDE7FF"]
  },
  "labor": {
    backgrounds: ["#332E2E","#5A4B3A","#8A6E4C"],
    texts:       ["#FFFFFF","#FFEFD7","#FFF3E6"]
  },
  "halloween": {
    backgrounds: ["#FF7A00","#CC5500","#FFA531"],
    texts:       ["#1A1A1A","#332222","#2A1200"]
  },
  "thanksgiving": {
    backgrounds: ["#A66124","#C97A2C","#E89A4F"],
    texts:       ["#FFF7E6","#FFEFD7","#FFF1C9"]
  },
  "christmas": {
    backgrounds: ["#8B0000","#0F4D1A","#004C3F"],
    texts:       ["#FFFFFF","#FFE8A3","#FFFAF2"]
  }
};

/* mapping holiday -> runner character keys (multiple possible) */
const RUNNERS_BY_HOLIDAY = {
  "thanksgiving": ["turkey"],
  "christmas": ["santa"],
  "newyears": ["rocket","party"],
  "valentine": ["cupid"],
  "stpatricks": ["leprechaun"],
  "easter": ["bunny"],
  "halloween": ["pumpkin"],
  "independence": ["rocket"],
  "labor": ["worker"],
  "memorial": ["flag"]
};

/* runner asset filename patterns (put these into assets/) */
/* e.g. assets/turkey-run.webp OR assets/turkey-run.gif OR assets/turkey-sprite.png */
const RUNNER_EXT_ORDER = ["-run.webp","-run.gif","-sprite.png"];

/* color cycle timing */
const COLOR_CYCLE_MS = 3000;

/* runner random timing (ms) when holiday active */
const RUNNER_MIN_MS = 15000; // min 15s
const RUNNER_MAX_MS = 90000; // max 90s

/* runner travel duration (seconds) across the screen */
const RUN_DURATION_SEC = 6; // will be scaled by screen width in JS

/* ============================
   UTIL / DATE HELPERS
   ============================ */

// Easter (Western) — Anonymous Gregorian algorithm
function easterDate(year) {
  const a = year % 19;
  const b = Math.floor(year / 100);
  const c = year % 100;
  const d = Math.floor(b / 4);
  const e = b % 4;
  const f = Math.floor((b + 8) / 25);
  const g = Math.floor((b - f + 1) / 3);
  const h = (19*a + b - d - g + 15) % 30;
  const i = Math.floor(c / 4);
  const k = c % 4;
  const l = (32 + 2*e + 2*i - h - k) % 7;
  const m = Math.floor((a + 11*h + 22*l) / 451);
  const month = Math.floor((h + l - 7*m + 114) / 31);
  const day = ((h + l - 7*m + 114) % 31) + 1;
  return new Date(year, month-1, day);
}

function nthWeekdayOfMonth(year, monthIndex, weekday, n) {
  const first = new Date(year, monthIndex, 1);
  const firstWeekday = first.getDay();
  let day = 1 + ((7 + weekday - firstWeekday) % 7) + (n-1)*7;
  return new Date(year, monthIndex, day);
}
function lastWeekdayOfMonth(year, monthIndex, weekday) {
  const last = new Date(year, monthIndex+1, 0);
  const lastWeekday = last.getDay();
  let day = last.getDate() - ((7 + lastWeekday - weekday) % 7);
  return new Date(year, monthIndex, day);
}

/* return Date for holiday config in a given year */
function holidayDate(h, year) {
  if (h.d === "easter") return easterDate(year);
  if (h.d === "fourthThursday") return nthWeekdayOfMonth(year, 10, 4, 4);
  if (h.d === "firstMonday") return nthWeekdayOfMonth(year, 8, 1, 1);
  if (h.d === "lastMonday") return lastWeekdayOfMonth(year, 4, 1);
  if (typeof h.d === "number") return new Date(year, h.m-1, h.d);
  return null;
}

/* get next or current holiday if in window; returns {active:boolean, holidayKey, holidayName, holidayDate} */
function getActiveHoliday() {
  const now = Date.now();
  const y = (new Date()).getFullYear();
  for (const h of HOLIDAYS) {
    let dt = holidayDate(h, y);
    if (!dt) continue;
    if (dt.getTime() < now - (24*60*60*1000)) { // if holiday already long past this year, try next year
      dt = holidayDate(h, y+1);
    }
    const start = dt.getTime() - PRE_WINDOW_MS;
    const end = dt.getTime() + (24*60*60*1000); // 1 day after
    if (now >= start && now <= end) {
      return { active:true, key:h.key, name:h.name, date:dt };
    }
  }
  return { active:false };
}

/* ============================
   AUTOSCALE (for font sizes)
   ============================ */
function applyScale() {
  const w = window.innerWidth || document.documentElement.clientWidth;
  const h = window.innerHeight || document.documentElement.clientHeight;
  let s = Math.min(w/REF_W, h/REF_H);
  s = Math.max(s, 0.55);
  s = Math.min(s, 3.0);
  document.documentElement.style.setProperty('--size-date',  Math.round(BASE.date * s) + 'px');
  document.documentElement.style.setProperty('--size-time',  Math.round(BASE.time * s) + 'px');
  document.documentElement.style.setProperty('--size-count', Math.round(BASE.count * s) + 'px');
  document.documentElement.style.setProperty('--size-today', Math.round(BASE.today * s) + 'px');
}

/* ============================
   COLOR CYCLING
   ============================ */
let colorIndex = 0;
let colorTimer = null;

function applyThemeColors(holidayKey) {
  // if no holidayKey -> set black/white
  if (!holidayKey || !THEME[holidayKey]) {
    document.documentElement.style.setProperty('--bg', '#000000');
    document.documentElement.style.setProperty('--fg', '#FFFFFF');
    return;
  }
  const pal = THEME[holidayKey];
  const i = colorIndex % pal.backgrounds.length;
  document.documentElement.style.setProperty('--bg', pal.backgrounds[i]);
  document.documentElement.style.setProperty('--fg', pal.texts[i]);
  colorIndex++;
}

/* manage cycling based on active holiday */
function startColorCycle(holidayKey) {
  if (colorTimer) clearInterval(colorTimer);
  if (!holidayKey) {
    applyThemeColors(null);
    return;
  }
  applyThemeColors(holidayKey);
  colorTimer = setInterval(()=>applyThemeColors(holidayKey), COLOR_CYCLE_MS);
}

/* ============================
   CLOCK + UI
   ============================ */
const elDate = document.getElementById('date');
const elTime = document.getElementById('time');
const elCount = document.getElementById('countdown');
const elToday = document.getElementById('today');

function updateClockAndCountdown() {
  const now = new Date();
  elDate.textContent = now.toLocaleDateString(undefined, { weekday:"long", month:"long", day:"numeric" });
  let raw = now.toLocaleTimeString([], { hour:"numeric", minute:"2-digit" });
  elTime.textContent = raw.replace(/ ?[AP]M?/i, "");

  const active = getActiveHoliday();
  if (active.active) {
    const days = Math.floor((active.date.getTime() - now.getTime()) / (1000*60*60*24));
    if (days <= 0) {
      elToday.textContent = "Happy " + active.name + "!";
      elCount.textContent = "";
    } else {
      elToday.textContent = "";
      elCount.textContent = `${days} day${days!==1 ? 's' : ''} until ${active.name}`;
    }
  } else {
    elToday.textContent = "";
    elCount.textContent = "";
  }
}

/* ============================
   RUNNERS (random)
   ============================ */

let runnerTimeout = null;
const activeRunners = new Set();

function randomBetween(min, max) { return Math.floor(Math.random()*(max-min))+min; }

function pickRunnerForHoliday(holidayKey) {
  const list = RUNNERS_BY_HOLIDAY[holidayKey] || [];
  if (list.length === 0) {
    // fallback pool
    return ["turkey","santa","bunny","pumpkin","rocket","cupid","leprechaun"][Math.floor(Math.random()*7)];
  }
  return list[Math.floor(Math.random()*list.length)];
}

function tryRunnerAsset(name) {
  // checks the asset filenames in order by creating an element and seeing if it loads.
  // We avoid HEAD requests — simply test by creating an image/video and handling onerror.
  return new Promise((resolve) => {
    const tryList = RUNNER_EXT_ORDER.map(ext => `assets/${name}${ext}`);
    let i = 0;
    (function nextTry(){
      if (i >= tryList.length) return resolve(null);
      const url = tryList[i];
      if (url.endsWith('.mp4') || url.endsWith('.webm')) {
        // prefer video? we didn't list mp4 in RUNNER_EXT_ORDER - but keep generic
        const v = document.createElement('video');
        v.src = url; v.muted = true; v.playsInline = true;
        v.onloadeddata = ()=> resolve({url, type:'video'});
        v.onerror = ()=> { i++; nextTry(); };
      } else if (url.endsWith('.webp') || url.endsWith('.gif')) {
        const img = new Image();
        img.src = url;
        img.onload = ()=> resolve({url, type:'img'});
        img.onerror = ()=> { i++; nextTry(); };
      } else if (url.endsWith('-sprite.png')) {
        // assume sprite sheet available; let caller treat specially
        const img = new Image();
        img.src = url;
        img.onload = ()=> resolve({url, type:'sprite', frames:6}); // default frames
        img.onerror = ()=> { i++; nextTry(); };
      } else {
        i++; nextTry();
      }
    })();
  });
}

async function spawnRunner(holidayKey) {
  if (!holidayKey) return; // only run during holiday windows

  // randomly decide whether to spawn this time (50% chance) to keep it gentle
  if (Math.random() < 0.4) return scheduleNextRunner(); // skipped

  const runnerKey = pickRunnerForHoliday(holidayKey);
  const candidateNames = [
    `${runnerKey}-run`,     // e.g. turkey-run.webp/gif
    `${runnerKey}-sprite`   // e.g. turkey-sprite.png
  ];

  // try assets
  let asset = null;
  for (const candidate of candidateNames) {
    asset = await tryRunnerAsset(candidate);
    if (asset) break;
  }

  // if no asset, abort
  if (!asset) return scheduleNextRunner();

  // create element
  const el = document.createElement('div');
  el.className = 'runner';
  // size by viewport width so smaller screens have smaller runners
  const vw = Math.max(document.documentElement.clientWidth, window.innerWidth || 480);
  // set width relative to viewport but clamp
  const widthPx = Math.max(60, Math.min(220, Math.round(vw * 0.18)));
  el.style.width = widthPx + 'px';

  // movement duration: scale with screen width so speed feels consistent
  const duration = Math.max(4, Math.round(RUN_DURATION_SEC * (vw / 480)));

  if (asset.type === 'img') {
    const img = new Image();
    img.src = asset.url;
    img.style.width = '100%';
    img.style.height = 'auto';
    el.appendChild(img);
  } else if (asset.type === 'video') {
    const v = document.createElement('video');
    v.src = asset.url; v.autoplay = true; v.loop = true; v.muted = true; v.playsInline = true;
    v.style.width = '100%';
    el.appendChild(v);
  } else if (asset.type === 'sprite') {
    // sprite sheet -- animate using background-position + steps
    const sprite = document.createElement('div');
    sprite.className = 'sprite-run';
    sprite.style.backgroundImage = `url("${asset.url}")`;
    sprite.style.backgroundSize = 'cover';
    sprite.style.width = '100%';
    sprite.style.height = '100%';
    // compute number of frames from image width/height? we don't know — assume 6
    const frames = asset.frames || 6;
    // create CSS animation for the sprite frames
    const stepAnimName = `spriteAnim_${Date.now()}_${Math.floor(Math.random()*1000)}`;
    const keyframes = `@keyframes ${stepAnimName} { 100% { background-position: -${100* (frames-1)}% 0; } }`;
    const styleTag = document.createElement('style');
    styleTag.innerHTML = keyframes;
    document.head.appendChild(styleTag);
    sprite.style.backgroundSize = (100 * frames) + '% 100%';
    sprite.style.animation = `${stepAnimName} ${0.8}s steps(${frames}) infinite`;
    el.appendChild(sprite);
  }

  document.body.appendChild(el);

  // start movement: use CSS animation for transform
  el.style.animation = `runAcross ${duration}s linear`;
  // remove element when animation ends
  el.addEventListener('animationend', () => { el.remove(); });

  // optionally add a subtle bob/pulse to the element
  el.animate([
    { transform: 'translateY(0)' },
    { transform: 'translateY(-6px)' },
    { transform: 'translateY(0)' }
  ], { duration: 900, iterations: Infinity });

  scheduleNextRunner(); // schedule the next one
}

/* schedule next runner at random interval only while holiday active */
function scheduleNextRunner() {
  if (runnerTimeout) clearTimeout(runnerTimeout);
  const active = getActiveHoliday();
  if (!active.active) { runnerTimeout = null; return; }
  const ms = randomBetween(RUNNER_MIN_MS, RUNNER_MAX_MS);
  runnerTimeout = setTimeout(()=> spawnRunner(active.key), ms);
}

/* ============================
   STARTUP
   ============================ */

let prevActiveKey = null;

function mainTick() {
  applyScale();
  updateClockAndCountdown();

  const active = getActiveHoliday();
  if (active.active) {
    // start color cycle with holiday key
    if (prevActiveKey !== active.key) {
      colorIndex = 0;
      startColorCycle(active.key);
      prevActiveKey = active.key;
      // start runners
      scheduleNextRunner();
    }
  } else {
    if (prevActiveKey !== null) {
      // holiday just ended
      startColorCycle(null);
      prevActiveKey = null;
    }
  }
}

/* manage color cycling start/stop */
function startColorCycle(key) {
  if (colorTimer) { clearInterval(colorTimer); colorTimer = null; }
  if (!key) {
    document.documentElement.style.setProperty('--bg', '#000000');
    document.documentElement.style.setProperty('--fg', '#FFFFFF');
    return;
  }
  // reset index and apply immediately
  colorIndex = 0;
  applyThemeColors(key);
  colorTimer = setInterval(()=> applyThemeColors(key), COLOR_CYCLE_MS);
}

/* initial scale + intervals */
applyScale();
updateClockAndCountdown();
mainTick(); // initial
setInterval(()=> { updateClockAndCountdown(); }, 1000);
setInterval(mainTick, 3000); // check holiday state + color cycle decisions

// Recompute scale on resize/orientation change
let resizeTimer = null;
window.addEventListener('resize', () => { clearTimeout(resizeTimer); resizeTimer = setTimeout(applyScale, 80); });
window.addEventListener('orientationchange', () => { setTimeout(applyScale, 200); });

/* expose helper for debug (optional) */
window.__holidayClock = {
  getActiveHoliday,
  spawnRunnerNow: () => { const a = getActiveHoliday(); if (a.active) spawnRunner(a.key); },
  applyScale
};
</script>
</body>
</html>
